(*^::[paletteColors = 128; 	fontset = title, "New York", 24, L3, center, bold, nohscroll;	fontset = subtitle, "New York", 18, L2, center, bold, nohscroll;	fontset = subsubtitle, "New York", 14, L2, center, bold, nohscroll;	fontset = section, "New York", 14, L2, bold, nohscroll, grayBox;	fontset = subsection, "New York", 12, L2, bold, nohscroll, blackBox;	fontset = subsubsection, "New York", 10, L2, bold, nohscroll, whiteBox;	fontset = text, "Monaco", 12, L2, bold, nohscroll;	fontset = smalltext, "New York", 10, L2, nohscroll;	fontset = input, "Geneva", 12, L2, nowordwrap;	fontset = output, "Monaco", 12, L2, nowordwrap;	fontset = message, "Monaco", 12, L2, R65535, nowordwrap;	fontset = print, "Monaco", 12, L2, bold, nowordwrap;	fontset = info, "Courier", 12, L2, nowordwrap;	fontset = postscript, "Courier", 12, L2, nowordwrap;	fontset = name, "Geneva", 10, L2, italic, B65535, nowordwrap, nohscroll;	fontset = header, "Times", 10, L2;	fontset = footer, "Times", 12, L2, center;	fontset = help, "Geneva", 10, L2, nohscroll;	fontset = clipboard, "New York", 12, L2;	fontset = completions, "New York", 12, L2, nowordwrap;	fontset = network, "Courier", 10, L2, nowordwrap;	fontset = graphlabel, "Courier", 12, L2, nowordwrap;	fontset = special1, "New York", 12, L2, nowordwrap;	fontset = special2, "New York", 12, L2, center, nowordwrap;	fontset = special3, "New York", 12, L2, right, nowordwrap;	fontset = special4, "New York", 12, L2, nowordwrap;	fontset = special5, "New York", 12, L2, nowordwrap;]:[font = input; inactive; ](*	theta: vettore dei parametri	xx, yy: vettori delle osservazioni	x, y: singole osservazioni*);[o]Null:[font = input; initialization; ]*)ClearAll[term, sumSquares, termDerivate, gradientElement, fit, 	newTabataInt, adjustHistory, history](*:[font = input; initialization; ]*)term[model_, theta_List, x_Real, y_Real] := model[ theta, x ] - y(*:[font = input; initialization; ]*)sumSquares[ model_, theta_List, xx_List, yy_List ] :=	Block [		{ i },		Sum[ term[ model, theta, xx[[i]], yy[[i]] ]^2, 				{i, Length[xx]} ]	](*:[font = input; initialization; ]*)termDerivate [	model_, 						theta_List,						xx_List, 						indexObs_Integer,						indexTheta_Integer ] :=	Block [		{			h1,			h2,			theta2,			epsilon = 10.^-5		},		h1 = model[theta, xx[[indexObs]] ];		theta2 = theta;		theta2[[indexTheta]] = theta[[indexTheta]] + epsilon;		h2 = model[theta2, xx[[indexObs]] ];		(h2 - h1)/epsilon	](*:[font = input; initialization; ]*)gradientElement[i_Integer] := 			2 Sum[ term[model, theta, xx[[j]], y[[j]] ] jacobian[[i, j]] , 						{j, Length[[xx]] } ];(*:[font = input; initialization; startGroup; ]*)adjustHistory [history_List, what_] :=	history[[1]] := history[[2]];	history[[2]] := history[[3]];	history[[3]] := what;	history(*:[font = message; inactive; ]Part::noval: Symbol history in part assignment does not have an     immediate value.:[font = message; inactive; ]Part::noval: Symbol history in part assignment does not have an     immediate value.:[font = output; inactive; output; endGroup; ]history;[o]history:[font = input; initialization; startGroup; ]*)newTabataInt [{ undefined, increased, decreased}, oldInt_Integer] = oldInt - 1(*:[font = output; inactive; output; endGroup; ]-1 + oldInt;[o]-1 + oldInt:[font = input; initialization; startGroup; ]*)newTabataInt [{ undefined, decreased, increased}, oldInt_Integer] = oldInt - 1(*:[font = output; inactive; output; endGroup; ]-1 + oldInt;[o]-1 + oldInt:[font = input; initialization; startGroup; ]*)newTabataInt [{ increased, decreased, increased}, oldInt_Integer] = 	If [oldInt > 1, oldInt - 1, 1](*:[font = output; inactive; output; endGroup; ]If[oldInt > 1, oldInt - 1, 1];[o]If[oldInt > 1, oldInt - 1, 1]:[font = input; initialization; startGroup; ]*)newTabataInt [{ decreased, decreased, increased}, oldInt_Integer] =  	If [oldInt > 1, oldInt - 1, 1](*:[font = output; inactive; output; endGroup; ]If[oldInt > 1, oldInt - 1, 1];[o]If[oldInt > 1, oldInt - 1, 1]:[font = input; initialization; startGroup; ]*)newTabataInt [{ increased, increased, decreased}, oldInt_Integer] =  	If [oldInt > 1, oldInt - 1, 1](*:[font = output; inactive; output; endGroup; ]If[oldInt > 1, oldInt - 1, 1];[o]If[oldInt > 1, oldInt - 1, 1]:[font = input; initialization; startGroup; ]*)newTabataInt [{ decreased, decreased, decreased}, oldInt_Integer] =  	If [oldInt < 5, oldInt + 1, 5](*:[font = output; inactive; output; endGroup; ]If[oldInt < 5, oldInt + 1, 5];[o]If[oldInt < 5, oldInt + 1, 5]:[font = input; initialization; startGroup; ]*)newTabataInt [{ increased, increased, increased}, oldInt_Integer] =  	If [oldInt < 3, 3, oldInt](*:[font = output; inactive; output; endGroup; ]If[oldInt < 3, 3, oldInt];[o]If[oldInt < 3, 3, oldInt]:[font = input; initialization; ]*)fit[ model_, theta0_List, xx_List, yy_List ] :=	Block [		{			i,			j,			NPar = Length[theta],			NObs = Length[xx],			lambda = 0.1,			tabataFactor = { 1.33, 1.78, 3.16, 10., 100. },			tabataInt = 4,			history = { undefined, undefined, undefined },			oldSum = sum = sumSquares[model, theta0, x, y],			oldTheta = theta = theta0,			hessian,			jacobian,			gradient,			direction,			alfa		},				While [True,			jacobian = Table [ termDerivate[ model, theta, xx, yy , i, j ],										{i, NObs}, {j, NPar} ];			gradient = Table [gradientElement[i], {i, NPar} ];			hessian = Transpose[jacobian] jacobian;			print["hessian", hessian];			If [Det[hessian] < 10^-6, hessian = hessian + lambda IdentityMatrix[NPar] ];		Label[retry];			direction = LinearSolve[hessian, gradient];			alfa = FindMinimum [ sumSquares[ model, theta + alfa direction, xx, yy],											 {alfa , 1}];			newTheta = theta + alfa direction;			newSum = sumSquares[model, thetaNew, xx, yy];			If [newSum < sum,				If [testConvergence, Return[newSum, newTheta] ];				history = adjustHistory[history, decreased];				tabataInt = newTabataInt[history, tabataInt];				lambda /= tabataFactor[[tabataInt]];				sum = newSum			,				history = adjustHistory[history, increased];				tabataInt = newTabataInt[history, tabataInt];				lambda *= tabataFactor[[tabataInt]];				hessian = hessian + lambda IdentityMatrix[NPar];				Goto [retry]			]		]	]		(*:[font = input; initialization; ]*)singleExp [theta_List, x_Real] := theta[[1]] E^(-theta[[2]] x)(*:[font = input; startGroup; ]fit[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1} ]:[font = message; inactive; ]Part::selectform:    Part specification xx is neither an integer nor a list of nonzero     integers.:[font = message; inactive; ]Part::selectform:    Part specification j is neither an integer nor a list of nonzero     integers.:[font = message; inactive; ]Part::selectform:    Part specification j is neither an integer nor a list of nonzero     integers.:[font = message; inactive; ]General::stop:    Further output of Part::selectform     will be suppressed during this calculation.:[font = message; inactive; ]Thread::badlen:    Objects of unequal length in     {{termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 1,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 2, 1],        termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 3,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 4, 1]},       {termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 1,         2], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 2, 2],        termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 3,         2], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 4, 2]}}      {{termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 1,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 1, 2]},       {termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 2,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 2, 2]},       {termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 3,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 3, 2]},       {termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4}, {4, 3, 2, 1}, 4,         1], termDerivate[singleExp, {1., 1.}, {1, 2, 3, 4},         {4, 3, 2, 1}, 4, 2]}} cannot be combined.:[font = message; inactive; ]Thread::badlen:    Objects of unequal length in     {{termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 1.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 2.]}}      {{termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 2.]}} cannot be combined.:[font = message; inactive; ]NSum::base: Upper or lower limit of summation Length[[xx]]     is not a number.:[font = message; inactive; ]NSum::base: Upper or lower limit of summation Length[[xx]]     is not a number.:[font = message; inactive; ]NSum::base: Upper or lower limit of summation Length[[xx]]     is not a number.:[font = message; inactive; ]General::stop:    Further output of NSum::base     will be suppressed during this calculation.:[font = message; inactive; ]Thread::badlen:    Objects of unequal length in     {{termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 1.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 2.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 2.]}}      {{termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 1., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 2., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 3., 2.]},       {termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 1.],        termDerivate[singleExp, {1., 1.}, {1., 2., 3., 4.},         {4., 3., 2., 1.}, 4., 2.]}} cannot be combined.:[font = message; inactive; ]General::stop:    Further output of Thread::badlen     will be suppressed during this calculation.:[font = message; inactive; ]-interrupted-:[font = output; inactive; output; endGroup; ]$Interrupted;[o]$Interrupted^*)