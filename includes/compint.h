/*	File compint.h	This file is part of EasyFit, a nonlinear fitting program for the Macintoshª.		Copyright © 1989-1991 Matteo Vaccari & Mario Negri Institute.	All rights reserved.*/#ifndef __COMPINT__#define __COMPINT__#include <setjmp.h>#include <types.h>#define qFuncDefs 1/* le lunghezze delle istruzioni */#define LONG 	(1 + sizeof(extended)/sizeof(short))#define MED		2#define SHORT	1/* il numero di posizioni nello stack */#define STACK_SIZE 100/* la lunghezza del segmento codice (in short words). Compilando		in maniera debug siamo costretti a fare economia di memoria. */#if qDebug#	define CODESEG_SIZE (1 * 1024)#else#	define CODESEG_SIZE (7 * 1024)#endif/* deve corrispondere a kMaxParams in fitglob.p */#define MAX_PARAMS 20/* il max. num di variabili utente */#define MAX_USER_VARS 100/* Il max n. di argomenti che una funzione definita dall'utente puo' avere.	Limitato dalola lunghezza dei campi n_args e arg_map nella struct st_entry */#define MAX_USER_FUNC_ARGS 16/* la lunghezza del segmento dati (in extended). */#define DATASEG_SIZE (MAX_PARAMS + MAX_USER_VARS + 2)/* il numero di parole riservate */#if qFuncDefs#define NO_RESERVED_WORDS 32		/* FUNCTION, VAR */#else#define NO_RESERVED_WORDS 30#endif/* la dimensione della symbol table: room for globals, reserved words and locals */#define ST_SIZE (DATASEG_SIZE + NO_RESERVED_WORDS + 100)/* definizioni di tipo per la symbol table */typedef struct st_entry_struct {#if qFuncDefs		unsigned global:1;		unsigned func_name:1;								/* means that the symbol is a function name */		unsigned function_being_defined:1;	/* allows assignment to function name */		unsigned n_args:4;									/* the number of arguments of a function */		unsigned short arg_map;							/* Array of boolean: 1 means functional																					 argument, 0 means numerical argument */#endif		char *name;				/* puntatore al nome della var */		short token;			/* il token cui corrisponde */		short address;		/* l'indirizzo, nel caso di una variabile */} st_entry, *p_st_entry;	#define ASSIGN_ST_ENTRY(a,b)  {Ê\		(a)->global = (b)->global; \		(a)->func_name = (b)->func_name; \		(a)->function_being_defined = (b)->function_being_defined; \		(a)->n_args = (b)->n_args; \		(a)->arg_map = (b)->arg_map; \		(a)->name = (b)->name; \		(a)->token = (b)->token; \		(a)->address = (b)->address; \	}/* i tokens restituiti dall' analizzatore lessicale */#define T_END			1#define T_FOR			2#define T_DO			3#define T_IF			4#define T_TO			5#define T_EXP			6#define T_SIN			7#define T_COS			8#define T_TAN			9#define T_XPWRY		10#define T_SQRT		11#define T_ABS			12#define T_SIGN		13#define T_LOG			14#define T_IN			15#define T_ATN			16#define T_ASSIGN	17#define T_SEMICOLON		18#define T_LPAR		19#define T_RPAR		20#define T_COMMA		21#define T_EOSTR		22#define T_LT			23#define T_GT			24#define T_LTE			25#define T_GTE			26#define T_EQ			27#define T_NEQ			28#define T_PLUS		29#define T_MINUS		30#define T_TIMES		31#define T_DIV			32#define T_ID			33#define T_BEGIN		34#define T_LN			35#define T_OR			36#define T_NOT			37#define T_AND			38#define T_WHILE		39#define T_REPEAT	40#define T_CONST		41#define T_THEN		42#define T_ELSE		43#define T_MACSQRT	44#define T_UNTIL		45#define T_BEEP		46#define T_SQR			47#define T_CUBE		48#define T_EXIT		49#define T_PRINT		50#define T_INT			51#if qFuncDefs#define T_FUNCTION 52#define T_VAR			53#endif/* procedure & funzioni */short scanner();short lookup();short lookup_address(int addr);short insert();void init_st();void free_st();#if qDebugvoid dump_st();#endif#if qFuncDefsvoid remove_non_globals_from_st();#endifshort compile();void gen_instr(int, int, extended);void patch_address();void init_compiler();extended interpret();void compiler_error();void match_error();#if qDebugvoid dump_codeseg();#endif/* var globali */extern short codeseg[];extern short curr_addr;extern short instr_len[];extern char *input;extern extended dataseg[];extern short last_var;extern extended numconst;extern st_entry *st;extern int identifiers_are_global;extern int identifier_is_func_name;extern int identifier_must_be_unique;extern short compiler_state;extern jmp_buf env;extern int charcount;extern int user_model_params;extern Str255 error_msg;extern int model_may_change_focus;/* codici di errore restituiti dalle routines del comp-interprete */#define SYNTAX_ERROR 1#define TOO_MUCH_CODE 2#define EOINPUT_UNEXPECTED 3#define ILLEGAL_SYM 4#define ILLEGAL_CHAR 5#define ST_FULL 6#define LEXEMES_FULL 7#define TOO_MANY_PARAMS 8#define TOO_MANY_VARS 9#define I_WAS_EXPECTING 10#define NOT_USING_PARAMS 11#define WRONG_NUMBER_OF_ARGS 12#define TOO_MANY_ARGS_IN_USER_FUNCTION 13#define ASSIGNMENT_TO_WRONG_NAME 14#define EXPECTING_NAME 15#define REDEFINED_NAME 16#define FUNC_NAME_EXPECTED 17/* codici delle istruzioni pseudo-assembler */#define PUSHC 0#define PUSH 	1#define COPY	2#define EXIT	3#define POP		4#define POP1	5#define BNZ		6#define BLT		7#define GOTO	8#define BZ		9#define INCR	10#define	ADD		11#define SUB		12#define UMINUS 13#define MULT	14#define DIV		15#define EXP		16#define SIN		17#define COS		18#define TAN		19#define XPWRY	20#define SQRT	21#define GT		22#define GTE		23#define LT		24#define LTE		25#define NEQ		26#define EQ		27#define ABS		28#define SIGN	29#define LOG		30#define LN		31#define ATN		32#define OR		33#define AND		34#define NOT		35#define BEEP	36#define SQR		37#define CUBE	38#define PRINT 39#define INT		40#if qFuncDefs#define PUSHBB	41#define POPBB	42#define POPN	43#define JSR		44#define RTS		45#define JSRBB	46#define PRINTBB	47#define INCRBB 48#endif/* queste routines sono come quelle di ctype.h; solo che queste	supportano l'extended char set del Mac e considerano l'underscore	una lettera *//* my_isalpha - true sse c appartiene a a-z, A-Z oppure e' underscore */#define my_isalpha(c) ((c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') || c == underscore)/* my_isalnum - true sse c e' una lettera, un numero o underscore */#define my_isalnum(c) (my_isalpha(c) || c >= '0' && c <= '9' || c == underscore)/* my_isdigit - true sse c e' una cifra 0-9 */#define my_isdigit(c) (c >= '0' && c <= '9')/* my_isspace - true sse c e' blank, tab, return, newline, vtab o	form feed */#define my_isspace(c) (c == blank || c == tab || c == ret || c == nl || c == vtab || c == ffeed)#define my_tolower(c) (c>='A' && c<='Z' ? c - 'A' + 'a' : c)#endif __COMPINT__