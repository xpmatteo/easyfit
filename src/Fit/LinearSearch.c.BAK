/*  This file is part of EasyFit, a nonlinear fitting program for the Macintoshª.		Copyright © 1989-1990 Matteo Vaccari & Mario Negri Institute.*/#include "fit.h"static void computeTempParams();#define ALL_INFINITY(n1, n2, n3)	(INF(n1) && INF(n2) && INF(n3))#define IS_NAN(nnn)								((nnn) == QNAN || (nnn) == SNAN)#define ALL_NAN(n1, n2, n3)				(IS_NAN(n1) && IS_NAN(n2) && IS_NAN(n3))linearSearchStep1(extended	X[],								  extended	Y[],								  int				NObservations,#if !SPEEDUP				  				extended	params[],#endif									int				NParams,									extended	(*model)(),									extended	sqrtWeights[],									extended	direction[],									extended	tempParams[],									extended	*pSum,									int				useWeights,									int				useELS#if qConstraints									,									extended	low_constr[],									extended 	hi_constr[])#else									)#endif/* ------------------------------------------------------------------	Questa funzione esegue la prima parte della ricerca lungo la linea	individuata dal vettore "direction".	Come sottoprodotto, si ha il computo della somma.  Questo viene	passato all' esterno attraverso la variabile "sum" che viene	passata per indirizzo.	Calcoliamo le tre somme		COMPUTE_SUM(params + alfa * direction)	per alfa = 1/3, 2/3, 1;	Valori restituiti:		OVERFLOW_IN_LIN_SEARCH:	tutte e tre le somme sono infinite;		ONE_THIRD: 	il minimo e' per alfa = 1/3;		TWO_THIRDS:  "   "    "   "   "   = 2/3;		ONE:							  = 1.		INVALID_FIRST_TRY: this means that with alfa=1/3 the parameters are not			in the admissible region, with respect to the constraints. This			means that for alfa>1/3 the params can't be valid either.		SUM_IS_NAN: all three of the sums are NAN. The program should be		able to recover if one of the sums is not. Actually this is not		a returned value, because we do a longjmp if this happens. ------------------------------------------------------------------*/{	extended sum1, sum2, sum3;	extended min;	int retValue;	int classSum1, classSum2, classSum3;#if SPEEDUP	vectorSum(tempParams, direction, NParams);#else	computeTempParams(tempParams, params, direction, 1.0/3.0, NParams);#endif#if qConstraints	if (invalid_point(tempParams, NParams, low_constr, hi_constr)) {		#if qDebug		writeln("linear_search: alfa=1/3 leads to invalid point");		synch;		#endif		return INVALID_FIRST_TRY;	}#endif	if (useELS)		sum1 = ComputeELSSum(X,Y,NObservations,tempParams,NParams,model);	else		sum1 = ComputeSum(X,Y,NObservations,tempParams,model,sqrtWeights,useWeights);#if SPEEDUP	vectorSum(tempParams, direction, NParams);#else	computeTempParams(tempParams, params, direction, 2.0/3.0, NParams);#endif#if qConstraints	if (invalid_point(tempParams, NParams, low_constr, hi_constr)) {		/* We're entering the Forbidden Region: back up and give for good			last point */		#if qDebug		writeln("linear_search: alfa=2/3 leads to invalid point");		synch;		#endif		if ((classSum1 = classextended(sum1)) == INFINITE)			return OVERFLOW_IN_LIN_SEARCH;		if (IS_NAN(classSum1))			longjmp(setjmp_env, SUM_IS_NAN);		*pSum = sum1;		return ONE_THIRD;	}#endif	if (useELS)		sum2 = ComputeELSSum(X,Y,NObservations,tempParams,NParams,model);	else		sum2 = ComputeSum(X,Y,NObservations,tempParams,model,sqrtWeights,useWeights);#if SPEEDUP	vectorSum(tempParams, direction, NParams);#else	computeTempParams(tempParams, params, direction, 1.0, NParams);#endif#if qConstraints	if (invalid_point(tempParams, NParams, low_constr, hi_constr)) {		/* We're entering the Forbidden Region */		#if qDebug		writeln("linear_search: alfa=3/3 leads to invalid point");		synch;		#endif		if ((classSum1=classextended(sum1))==INFINITE					&& (classSum2=classextended(sum2))==INFINITE)			return OVERFLOW_IN_LIN_SEARCH;		if (IS_NAN(classSum1) && IS_NAN(classSum2))			longjmp(setjmp_env, SUM_IS_NAN);		if (IS_NAN(classSum2) || sum1 < sum2) {			*pSum = sum1;			return ONE_THIRD;		}		else {			*pSum = sum2;			return TWO_THIRDS;		}	}#endif	if (useELS)		sum3 = ComputeELSSum(X,Y,NObservations,tempParams,NParams,model);	else		sum3 = ComputeSum(X,Y,NObservations,tempParams,model,sqrtWeights,useWeights);	if (ALL_INFINITY(sum1, sum2, sum3))		return OVERFLOW_IN_LIN_SEARCH;		classSum1 = classextended(sum1);	classSum2 = classextended(sum2);	classSum3 = classextended(sum3);		if (ALL_NAN(classSum1, classSum2, classSum3))		longjmp(setjmp_env, SUM_IS_NAN);	/* Here we pick up the minimum, ignoring NANs, if any. */	if (IS_NAN(classSum2) || sum1 < sum2) {		min = sum1;		retValue = ONE_THIRD;	}	else {		min = sum2;		retValue = TWO_THIRDS;	}	if (IS_NAN(classextended(min)) || sum3 < min) {		min = sum3;		retValue = ONE;	}	*pSum = min;	return retValue;}/* ----------------------------------------------------------------------------- *//*	Esegue il secondo passo della ricerca lineare nella direzione	indicata da "direction".  Questa seconda parte viene eseguita	solo se nella prima parte si e' trovato che il passo migliore	era 1.  In questo caso si prosegue la ricerca lungo la	direzione a passi di 1/3, fino a un massimo valore di 4.	Ci fermiamo quando la somma cresce, o diventa NAN, o i parametri	escono dalla regione delimitata dai constraints.	La somma viene ancora una volta aggiornata da questa funzione,	come side-effect.*/extended linearSearchStep2(extended X[],													 extended Y[],													 int NObservations,#if !SPEEDUP						 							 extended params[],#endif													 													 int NParams,													 extended (*model)(),													 extended sqrtWeights[],													 extended direction[],													 extended tempParams[],													 extended *sum,													 int	useWeights,													 int 	useELS#if qConstraints													 ,													 extended	low_constr[],													 extended hi_constr[])#else													 )#endif{	extended alfa, alfaTemp;		/* la dimensione del passo */	extended min;								/* la somma piu' bassa finora trovata */	extended sumTemp;	min = *sum;	alfa = 1.0;	for(alfaTemp=4.0/3.0; alfaTemp<=4.0; alfaTemp+=1.0/3.0) {#if xqDebug		sprintf(msgStr,			"LinSearch2: loop: alfaTemp = %.3f, min = %.20g", alfa, min);		writeln(msgStr);		synch;#endif#if SPEEDUP		vectorSum(tempParams, direction, NParams);#else		computeTempParams(tempParams, params, direction, alfaTemp, NParams);#endif		if (useELS)			sumTemp = ComputeELSSum(X,Y,NObservations,tempParams,NParams,model);		else			sumTemp = ComputeSum(X,Y,NObservations,tempParams,model,sqrtWeights,useWeights);		if (sumTemp > min#if qConstraints				||				invalid_point(tempParams, NParams, low_constr, hi_constr)#endif				||				IS_NAN(classextended(sumTemp)))			break;		else {			min = sumTemp;			alfa = alfaTemp; /* aggiorna alfa */		}	}#if xqDebug	sprintf(msgStr,		"LinSearch2: exiting with alfa = %.3f and sum = %.20g", alfa, min);	writeln(msgStr);	synch;#endif	*sum = min;	return alfa;}static void computeTempParams(tempParams, params, direction, alfa, dim)extended *params, *direction, alfa, *tempParams;{	copyVector(tempParams, direction, dim);	scalarMultiply(tempParams, alfa, dim);	vectorSum(tempParams, params, dim);}