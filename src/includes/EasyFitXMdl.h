/*		This file is part of EasyFit, a nonlinear fitting program for the Macintoshª.			Copyright © 1989-1991 Matteo Vaccari & Mario Negri Institute.		Definitions needed for EasyFit External Models (XMDL).*/#ifndef __TYPES__#include <Types.h>#endif#ifndef __EASYFITXMDL__#define __EASYFITXMDL__/* request codes */#define rInitialize			0#define rModelName			1#define rGiveNParams		2#define rPeeling				3#define rModel					4#define rFinalComputations	5#define rFinished				6/* peeling results */#define kPeelingOK			0#define kPeelingFailed	1/* initialize results */#define kInitializeOK			0#define kInitializeFailed	1/* CallBack request codes */#define cbWrite								0#define cbWriteln							1#define cbNewLine							2#define cbSynch								3#define cbPollEvents					4#define cbGetVersion					5#define cbFailNIL							6#define cbFailNILResource			7#define cbFailOSErr						8#define cbFailResError				9#define cbFailMemError				10#define cbFailure							11#define cbGetConfigRecord 		12#define cbNewPtr							13#define cbNewHandle						14#define cbBeginGetResources		15#define cbEndGetResources			16#define cbNumToString					17#define cbStringToNum					18/* Weighting methods */#define noWeights									0#define oneOverYObserved					1#define oneOverSquaredYObserved		2#define oneOverYEstimated					3#define oneOverSquaredYEstimated	4#define ELS												5		/* unused */#define inputByUser								6/*	The following structure is used to communicate with EasyFit. All	floating point values are passed as double. Extended format would	have caused troubles since the length of extended numbers changes	when the -mc68881 option is set.*/struct XMdlBlock {	int				request;		int				initializeResult;	/* used when request = rInitialize */	double		*XObservations;		/* used when request = rPeeling */	double		*YObservations;	double		*sqrtWeights;	int				weightsOption;	int				NObservations;	int				peelingResult;	double		*params;					/* used when request = rModel */	double		x;	double		dose;	int				subject;	double		y;	int				NParams;					/* used when request = rGiveNParams */		void			(*EntryPoint)();	/* stuff needed to call back to EasyFit */	int				callBackRequest;	long			callBackArguments[5];	long			callBackResults[5];};typedef struct XMdlBlock XMdlBlock;typedef XMdlBlock *XMdlBlockPtr;/*	The following structure is returned after a cbGetConfigRecord callback	to EasyFit. Most of it should not be of much interest. Also, you can	count on the systemVersion being >= $0600, because EasyFit needs 	system software 6.0 or later to run. For the meaning of most of	these numbers, refer to the documentation of SysEnvirons in Inside Mac.	Most XMDL developers will only need to check hasFPU, if compiling	with the -mc68881 option set.*/struct ConfigRecord {			/* Values from SysEnvirons (Version 1) */	short environsVersion;	short machineType;	short systemVersion;	short processor;	Boolean hasFPU;	Boolean hasColorQD;	short keyboardType;	short atDrvrVersNum;	short sysVRefNum;								/* Derived values */	Boolean hasROM128K;									/* ROM 128K - OR - Better */	Boolean hasHFS;	Boolean hasHierarchicalMenus;	Boolean hasScriptManager;	Boolean hasStyleTextEdit;	Boolean hasSoundManager;	Boolean hasWaitNextEvent;	Boolean hasSCSI;	Boolean hasDesktopBus;	Boolean hasAUX;	Boolean hasTempMem;								/* TRUE if Multifinderª temp memory is avail */	Boolean has32BitQD;								/* TRUE if 32 bit Quickdraw is installed */};typedef struct ConfigRecord ConfigRecord;typedef ConfigRecord *ConfigRecordPtr;/*	Procedures used to make callbacks to EasyFit. You can request	"services" to EasyFit while executing your XMDL code, and these	functions are the way to ask for them!	The first parameter	of all of these functions must be	the same XMdlBlockPtr you are	passed by EasyFit	when execution passes to the XMDL.*/		/* Messages-window-writing procedures. */void EFWriteln(XMdlBlockPtr pb, char *msg);void EFWrite(XMdlBlockPtr pb, char *msg);void EFNewLine(XMdlBlockPtr pb);	/* Returns the version of EasyFit; call it if your XMDL has		 compatibility problems with particular versions of EasyFit. */void EFGetVersion(XMdlBlockPtr pb, int *majorRevision, int *minorRevision,									char *stage, int *release, Boolean *fpu);	/* Failure callers: use them to check for every kind of error that may		happen in your code. The remaining XMDL code will be skipped, the fitting		will be stopped, and an appropriate alert will appear.		You don't need to know much about the workings of this. However, full		explanation of the workings of this may be found in the MacApp file		UFailure.p, or in the UFailure unit you can find in the		Macintosh Developer's CD-ROM.		You can find hints about how to use MacApp's failure mechanism in C		in the file called "Object Pascal to C++" or something, also in the same		CD-ROM. */	/* Call this with a pointer or handle; this signals a failure if p is NIL. */void EFFailNIL(XMdlBlockPtr pb, void *p);	/* Call this with a resource handle; this signals Failure if the handle is nil.		 The error is either that returned by ResError, or resNotFound if ResError		 returns no error. */void EFFailNILResource(XMdlBlockPtr pb, void *p);	/* IF OSErr <> noErr THEN we call a failure.		(See the discussion of ResError in Inside Macintosh.) */void EFFailOSErr(XMdlBlockPtr pb, OSErr err);	/* IF ResError <> noErr THEN we call a failure.		(See the discussion of ResError in Inside Macintosh.) */void EFFailResError(XMdlBlockPtr pb);	/* IF MemError <> noErr THEN we call a failure.		(See the discussion of MemError in Inside Macintosh.) */void EFFailMemError(XMdlBlockPtr pb);		/* This calls a failure without conditions. Use to stop the fitting		if an unrecoverable error happens. */void EFFailure(XMdlBlockPtr pb);	/* Returns the Macintosh configuration. Use it if your XMDL has 		 compatibility problems with particular versions of the hardware;		 typically, if the XMDL was compiled with the -mc68881 option, you		 must check that the Macintosh we are using really has the floating		 point coprocessor. */ConfigRecordPtr EFGetConfigRecord(XMdlBlockPtr pb);	/*		Memory allocating functions. It is not easy to allocate globals in a		stand-alone code module like an XMDL. If you want to do it, you better		read Tech Note#256. 		If you want to allocate memry from the heap, it is better		to use EFNewPtr and EFNewHandle instead of the memory manager routines		NewPtr and NewHandle. This is because of MacApp's memory management		scheme (MacApp has been used in the making of EasyFit.)		The Ptrs and Handles returned from these functions are perfectly		good Memory Manager Ptrs and Handles. If no memory is available,		a NULL pointer or handle is returned. You better check it with FailNIL.		For instance:				{			Handle h;			h = EFNewHandle(pb, 10000);			FailNIL(h);			... 							-- do something with h			DisposHandle(h);	-- (a Memory Manager routine)		}				If h is nil, then control passes to MacApp's failure handling mechanism,		and the fitting stops. */Ptr EFNewPtr(XMdlBlockPtr pb, long size);Handle EFNewHandle(XMdlBlockPtr pb, long size);	/* Use the following functions to parenthesize calls to Resource Manager 		 functions GetResource() and similar. They are needed because EasyFit keeps		 itself as the current res file. Calling EFBeginGetResources() sets		 the current res file to the last opened res file, while EFEndGetResources()		 sets it back to EasyFit. Don't forget to call EFEndGetResources() immediately		 after calling GetResource() ! Failure to do so may result in		 EasyFit loading XMDL resources believing they are EasyFit's. 		 Also read Tech Note #232 for a bug with OpenRFPerm with the -b compiler		 option.		 	Example: you want to load a resource of type TEXT:							EFBeginGetResources(pb);							 pb is the XMDL's params block				aHandle := GetResource('TEXT', 1000);	 load the resource				EFEndGetResources(pb);								 restore the res file _before_																								 checking for error				FailNilResource(aHandle);							 check for error						 */void EFBeginGetResources(XMdlBlockPtr pb);void EFEndGetResources(XMdlBlockPtr pb);	/* Conversion functions; these are useful since the use of sprintf() in 		stand-alone code leads to problems. What happens when you call		sprintf() is that some global variables are attached to your code by the		libraries. StdIO code uses these globals to speed up its internal operations		and simplify its code; to you this means only problems, because it's not		easy to use globals from stand-alone code. */		/* Conversion from double to string and from string to double; you must		create the string and pass its address. */void EFNumToString(XMdlBlockPtr pb, double num, char *string);	/* returns 1 if conversion was successful, 0 if it was not. You		must create the string. */int EFStringToNum(XMdlBlockPtr pb, char *string, double *num);#endif __EASYFITXMDL__