/*	This file is part of EasyFit, a nonlinear fitting program for the Macintoshª.		Copyright © 1989-1991 Matteo Vaccari & Mario Negri Institute.	All rights reserved.*/#ifndef __FIT__#define __FIT__#include <stdio.h>#include <setjmp.h>#include <Math.h>#include <strings.h>#include "declarations.r"#include "nrecipes.h"#include "MacApp.h"#include "m_indep.h"#if macintosh	#pragma segment Fit#endif/* ** ---------------------- costanti reali ------------------------------*/#define CONVERGENCE_TOLERANCE		1.0e-4#define NULL_DETERMINANT_TOLERANCE	1.0e-4#define CONVERGENCE_TEST_FACTOR		0.01#define LN2							0.6931471805599453094	/* Natural log of 2 *//*** --------------------- costanti intere ------------------------------*/#define TABATA_INT_AT_START 4/*** ----------------------------- Simboli ------------------------------****  Opzioni per la pesatura delle osservazioni*/#define NO_WEIGHTS              1#define ONE_OVER_SQUARED_Y      2#define FUNCTION_OF_VARIANCE    3/* valori booleani */#define TRUE	1#define FALSE	0/* numeri dei messaggi di errore; ctrl sempre la consistenza con	le risorse 'STR#' corrispondenti */#define eSmallSpace	2/***	i modelli. Controlla sempre che corrispondano a quelli definiti**	in UEasyFitDeclarations.p*/#define SINGLE_EXP 1#define TWO_EXP_PLUS 2#define TWO_EXP_MINUS 3#define THREE_EXP_PLUS 4#define THREE_EXP_MINUS 5#define USER_MODEL 6/***  valori della history della  minimizzazione*/#define UNDEFINED 0#define INCREASED 1#define DECREASED 2/*		valori di errore restituiti dalla procedura FIT e da altre.		Controlla sempre la consistenza con quelli definiti nella		procedura CallFit nel file UEasyFit.DoFit.p !!!*/#define NO_ERROR 					0#define INSUFFICIENT_MEMORY			1#define TOO_MANY_ITERATIONS			2#define BAD_INITIAL_ESTIMATE		3	/* sum overflow with initial										   estimate */#define TOO_FEW_OBSERVATIONS		4	/* there should be at least as										   many observations as parameters. */#define NULL_OBSERVATION			5	/* null observations may not be 										   allowed, depending on the 										   weights function chosen.  */#define OVERFLOW_IN_WEIGHTS			6	/* returned when one weight is too										   large */#define NO_CONVERGENCE_YET 			7#define CONVERGENCE					8#define SUM_LOWER_OR_EQUAL			9#define SUM_GREATER					10#define NO_SOLUTIONS				11#define OVERFLOW_IN_LIN_SEARCH		12#define ONE_THIRD					13#define TWO_THIRDS					14#define ONE							15#define USER_INTERRUPT				18#define INVALID_INITIAL_ESTIMATE	19 /* Initial estimate is out of constraints */#define CONSTRAINTS_LOOP_ERROR		20#define SUM_IS_NAN					21#define ERROR_IN_RECOMPUTEWEIGHTS	22#define PEELING_FAILED				23#define NO_PEELING_FUNC_AVAILABLE	24#define INVALID_FIRST_TRY			25	/* linear search stuff *//* ** ----------------------------  typedef --------------------------*/typedef extended (*func_ptr)();/***	Le variabili globali della procedura "fit"*/extern char			msgStr[];extern extended		scratch;extern jmp_buf		setjmp_env;extern pascal extended		gExtendedCurrentSubject;extern int			gCurrentSubject;extern extended 	*X;extern extended 	*Y;extern int			NObservations;extern int			NParams;extern int			useWeights;#if qELSextern int			useELS;#endifextern extended    	lambda;extern extended		*sqrtWeights;extern extended 	tabataFactor;extern int			tabataInt;extern func_ptr		model;extern extended		*low_constr;extern extended		*hi_constr;extern int			useConstraints;extern extended    	**HessMat;extern extended		**tempMat;extern extended    	*gradient;extern extended    	*oldParams;extern extended		*sqrtHessDiag;extern extended		*derParz;extern extended		*direction;extern extended		*valOfTabataFactor;extern extended		*tempParams;extern short 		*indx;extern short 		*minimHistory;/* ** ----------------------------  macro --------------------------------*/#define INF(x) (classextended(x) == INFINITE)#define IS_NAN(nnn) ((nnn) == QNAN || (nnn) == SNAN)#define MIN(aaa, bbb) ((aaa) < (bbb) ? (aaa) : (bbb))/* area of a triangle */#define TRIANGLE(base, height) (((base)*(height)) / 2.0)/* square and cube */#define SQR(xxx)	(scratch=(xxx), scratch*scratch)#define CUBE(xxx)	(scratch=(xxx), scratch*scratch*scratch)/* Used here and there. */#define CHECK_FOR_INTERRUPT	\	if (POLLEVENT()) Failure(kUserInterruptedFit,0);/*** ----------------------------  prototypes --------------------------*//* -------------- matrUtil.c */void    printVector(extended v[], int start, int end);void    printMatrix(extended **mat, int dim);void    copyVector(extended dest[], extended source[], int length);void    copyMatrix(extended **dest, extended **source, int len);void 	vectorSum(extended dest[], extended source[], int dim);void 	scalarMultiply(extended vect[], extended scalar, int dim);void 	makeZeroMatrix(extended **mat, int size);void 	makeZeroVector(extended p[], int size);void	WriteVectors(char *name1, extended v1[], char * name2, 			extended v2[], int from, int to);int		anyNull(extended v[], int start, int end);void	InvertMatrix(extended **a, int N, short indx[], extended **y);int		get_index_of_max(extended v[], int from, int to);/* ------------ scaling.c */void	scaleHessianAndGradient(void);void	scaleSolution(extended solution[]);/* ------------ varie */void computeHessianAndGradient(extended params[]);#if qELSvoid computeELSHessianAndGradient(extended X[],								  extended Y[],								  int NObservations,								  extended p[],								  int NParams,								  extended (*model)(extended *, extended),								  extended **H,								  extended gradient[]);#endifvoid marquardt(void);int computeParams(extended		params[],				  extended 		*pSum,				  extended 		oldSum,				  extended		oldParams[]);					  extended	absDeterminant(extended **workMat,						   extended **mat,						   int dim,						   short indx[]);						   extended	ComputeSum(extended params[], int useWeights);extended	ComputeELSSum(extended X[],						  extended Y[],						  int NObservations,						  extended params[],						  int NParams,						  extended (*model)());						  int			solveLinearSystem(extended sol[],							  extended **workMat,							  extended **coeffMat,							  extended knownVector[],							  int dimension,							  short indx[]);							  int			testForConvergence(extended params[], extended oldParams[]);void		updateParams(extended params[],						 extended direction[],						 extended stepSize,						 int dim);int			Peeling (extended X[],					 extended Y[],					 int NObs,					 int NExps,					 int FastestSignum,					 extended Param[],					 int Cuts[],					 extended W[],					 Boolean UseWeights);/* ------------ tabata.c */extended	newTabataFactorWhenIncreased(int *pTabataInt); extended	newTabataFactorWhenDecreased(int *pTabataInt);int			newTabataIntWhenDecreased(int oldInt);int			newTabataIntWhenIncreased(int oldInt);/* -------------- linearsearch.c */int linearSearchStep1(#if !SPEEDUP	extended params[],#endif													 	extended *pSum);extended linearSearchStep2(#if !SPEEDUP	extended params[],#endif													 	extended *sum);/* -------------- model.c */extended	single_exp(extended par[], extended x);extended	two_exp_plus(extended par[], extended x);extended	two_exp_minus(extended par[], extended x);extended	three_exp_plus(extended par[], extended x);extended	three_exp_minus(extended par[], extended x);int			get_NumberOfParams(int modelNumber);func_ptr	get_ModelFunc(int modelNumber);int			CallPeel(extended X[],					 extended Y[],					 int NObservations,					 extended params[],					 extended sqrtWeights[],					 int weightsOption,					 int modelNumber,					 int *cutPoint);void		SetUserModelNParams(int n);int			peel_single_exp(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);int			peel_two_exp_plus(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);int			peel_two_exp_minus(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);int			peel_three_exp_plus(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);int			peel_three_exp_minus(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);int			cant_peel(extended X[], extended Y[], int NObservations, extended params[], extended sqrtWeights[], int weightsOption, int *cutPoint);/* -------------- fit.c */int	fit (extended X_[],				 extended Y_[],				 int NObservations_,				 extended params[],				 int NParams_,				 int modelNumber,				 int useWeights_,#if qELS				 int useELS_,#endif				 extended sqrtWeights_[],				 extended lambda_,				 int maxIterations,#if qConstraints				 extended low_constr_[],				 extended hi_constr_[],#endif				 int theSubject,				 int fullOutput,				 int (*ReComputeWeights)(extended *X, int NObservations, extended *params, extended (*model)(), extended *sqrtWeights),				 int mustRefreshPlots);void			 computeSqrtHessDiag(void);/* -------------- Pharmacokin.c */void print_pharmacokin_data(extended	X[],							extended	Y[],							int			NObservations,							extended	params[],							int			modelNumber,							extended	dose);extended trapezoid(extended, extended, extended);extended integrate_AUC(extended a, extended b, extended T);extended integrate_MRT(extended a, extended b, extended T);extended integrate_VRT(extended a, extended b, extended T);void numerical_integration(		extended	X[],		extended	Y[],		int			NObservations,		extended	p[],		extended	(*F)(extended *, extended *, int), 		extended	(*first_area)(extended, extended, extended *, extended), 		extended	(*last_area)(extended *, extended),		extended	lagtime,		extended	*total_area,		int			verbose,		char		*last_area_message);void numerical_integration2(			extended	X[],			extended	Y[],			int				NObservations,			extended	p[],			extended	(*F)(extended *, extended *, int), 			extended	(*first_area1)(extended, extended, extended *, extended), 			extended	(*first_area2)(extended, extended, extended *, extended), 			extended	(*last_area)(extended *, extended),			extended	lagtime,			extended	*total_area1,			extended	*total_area2,			char		*first_area_msg);extended compute_AUC(extended *, extended *, int);extended compute_S1(extended *, extended *, int);extended compute_S2(extended *, extended *, int);void single_exp_pharmacokin_data(extended	X[],								 extended	Y[],								 int		NObservations,								 extended	params[],								 extended	dose);void two_exp_plus_pharmacokin_data(	extended	X[],									extended	Y[],									int		NObservations,									extended	params[],									extended	dose);void two_exp_minus_pharmacokin_data(extended	X[],									extended	Y[],									int		NObservations,									extended	params[],									extended	dose);void three_exp_minus_pharmacokin_data(extended	X[],									  extended	Y[],									  int		NObservations,									  extended	params[],									  extended	dose);/* -------------- Constraints.c */Boolean invalid_point(extended *);void print_constraints();Boolean constraints_in_use();/* -------------- ComputeWeights.c */void normalizeWeights(extended weights[], int NObservations);int computeWeights1OverSqObs(	extended Y[], 								int NObservations,								extended sqrtWeights[]);int computeWeights1OverObs(		extended Y[], 								int NObservations,								extended sqrtWeights[]);int ComputeWeights1OverEstimated(	extended X[], 									int NObservations,									extended params[],									extended (*model)(extended *, extended),									extended sqrtWeights[]);int ComputeWeights1OverSqEstimated(	extended X[], 									int NObservations,									extended params[],									extended (*model)(extended *, extended),									extended sqrtWeights[]);#endif